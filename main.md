# Ласкаво просимо!

У нашій Swift команді ми дотримуємося встановлених правил та стандартів написання коду, які допомагають підтримувати його чистим, зрозумілим та легким для подальшого розвитку. Основною метою наших принципів є забезпечення єдиного підходу до написання коду, що сприяє кращій командній взаємодії та мінімізує ризики, пов’язані з несумісністю.

# Для кого призначені ці правила?

Ці правила призначені для всіх розробників, які працюють над проєктом, незалежно від їхнього досвіду чи ролі в команді. Вони допомагають:

1. **Новим членам команди**: Швидше адаптуватися до стилю написання коду в проєкті, зрозуміти структуру та підходи до розробки.
2. **Досвідченим розробникам**: Забезпечити єдиний підхід до написання коду і спростити код-рев'ю.
3. **Командам, які підтримують проєкт**: Зробити код більш зрозумілим і легким для підтримки, особливо при масштабуванні проєкту.
4. **Контрактним розробникам**: Полегшити інтеграцію їхнього внеску в основний код проєкту завдяки зрозумілим стандартам.
5. **Усім, хто читає код**: Зменшити когнітивне навантаження за рахунок використання зрозумілого і послідовного стилю написання.

Дотримання цих правил дозволяє підвищити якість коду, сприяє кращій співпраці в команді та забезпечує довготривалу підтримку проєкту.

### Переваги використання єдиного кодстайлу:

- **Зрозумілість**: Уніфікований стиль спрощує читання та розуміння коду всіма членами команди.
- **Легкість підтримки**: Код, написаний за загальними правилами, простіше підтримувати та розвивати в майбутньому.
- **Зниження помилок**: Завдяки дотриманню стандартів зменшується кількість технічних помилок і конфліктів.
- **Ефективність**: Уніфіковані підходи до структуризації та стилю дозволяють зекономити час на рев’ю та інтеграцію коду.
- **Командна згуртованість**: Спільний стиль сприяє кращій взаємодії всередині команди та швидшому залученню нових учасників.

Ознайомтеся з цими правилами перед початком роботи, щоб ваш внесок став важливою частиною успіху нашого проєкту.

# Кілька важливих правил, які варто пам’ятати:

1. **Читабельність і ясність — головна мета.**  
   Код пишуть значно рідше, ніж читають або використовують в інших місцях. Вибравши правильне ім’я для методу чи змінної один раз, ви спрощуєте їх розуміння іншими розробниками.

2. **Ясність завжди має пріоритет над стислістю.**  
   Незважаючи на те, що в Swift можна писати дуже короткий код, це не повинно бути самоціллю. Назви змінних, методів і класів завжди мають відображати їхнє призначення, навіть якщо це робить їх довшими.

Дотримуючись цих принципів, ви допоможете зробити код вашої команди більш зрозумілим і зручним у роботі.

# Іменування та правила проектування API

Іменування змінних, класів, методів та іх аргументів є одним із ключових правил під час написання будь-якого коду. Коли члени команди керуються спільними правилами іменування, можна сказати, що вони "говорять однією мовою". Це полегшує розуміння коду під час його читання, а також сприяє ефективній комунікації між розробниками.

### Підходи до іменування та правила проектування API:

- **[ENG Swift API Design Guidelines](https://swift.org/documentation/api-design-guidelines/)**  
- **[RU Swift API Design Guidelines](https://github.com/tecktonikvov/code-design-guideline/blob/main/Swift%20API%20design%20guidelines.pdf)**


# Оголошення об'єктів

При оголошенні об'єктів (класи, протоколи) між назвою та початком блоку не робиться перенесення рядка:

```swift
class Formatter {
    var definition
}
```

# Префікси класів

Ми не використовуємо префікси для класів.

Swift автоматично додає префікси до назв класів (за назвою модуля), тому ситуації, коли два класи з однаковими назвами конфліктують, виключені. Якщо ж виникає конфліктна ситуація, можна використати назву модуля, щоб явно вказати, який клас слід використовувати:

```swift
import SomeModule

let service: SomeModule.Service
```

# Використання `// MARK:` у Swift

**// MARK:** — це потужний інструмент для структурування та навігації по коду, особливо у великих класах, структурах чи файлах. Його правильне використання допомагає покращити читабельність, полегшує розуміння коду та прискорює роботу з ним.

Використовуйте **// MARK:** для групування властивостей, методів та інших елементів.

## Навіщо використовувати?

1. **Покращення читабельності**: Розділяє логічні блоки коду (наприклад, властивості, методи, ініціалізатори).
2. **Прискорення навігації**: У Xcode розділи, позначені **// MARK:**, відображаються в меню навігації (мапа файлу).
3. **Зменшення когнітивного навантаження**: Структурує файл, полегшуючи роботу з ним.


## Приклади використання
 **1. Структура великого класу**

``` swift
final class ShoppingCartViewController: UIViewController {
    // MARK: - Properties
    private var items: [CartItem] = []

    // MARK: - Init
    init(items: [CartItem]) {
        self.items = items
        super.init(nibName: nil, bundle: nil)
    }

    required init?(coder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }

    // MARK: - Lifecycle
    override func viewDidLoad() {
        super.viewDidLoad()
        setupUI()
    }
    
    // MARK: - Public
    func items() -> [CarItem] {
    	return items
    }

    // MARK: - Private
    private func setupUI() {
        // Do something...
    }

    private func calculateTotal() -> Double {
        return items.reduce(0) { $0 + $1.price }
    }
}
```

## Висновок
* Використовуйте // MARK: для логічного структурування коду.
* Стандартизуйте підхід у команді.
* Дотримуйтесь простоти та читабельності, уникайте надмірної деталізації.

# Використання дужок

У загальному випадку символ "{" не переноситься на новий рядок. Приклади:

* **Умовні операції if, else:**

    ```swift
    if let user = users.first {
        doStuff()
    } else {
        doOtherStuff()
    }
    ```

* **Цикли for, while:**

    ```swift
    for item in items {
        item.doStuff()
    }
    ```

* **Визначення класів, протоколів:**

    ```swift
    protocol ServiceDelegate {
        func service(_ service: Service, didFinishLoading error: Error?)
    }
    ```

* **Використання MARK:**

    ```swift
    final class ViewPresenter {
        // MARK: - Private
        private var isShown = false

        // MARK: - Public
        func show() {
            isShown = true
        }
    }
    ```

* **Оператори switch:**

    ```swift
    switch self {
    case .case1: 
        return true
    case .case2: 
        return false
    }
    ```

# Вирази Guard
Під час використання guard-виразів слід дотримуватись загальних правил перенесення рядків:

```swift
func loadData() throws {
    guard !isLoaded else { 
        throw Exception.alreadyLoaded 
    }
}
```

Також дозволяється запис без перенесення, якщо результуючий вираз не є занадто довгим:

```swift
func createViewIfNeeded() {
    guard view == nil else { return }
}
```



# Рекомендації щодо використання if-else

Правильне використання конструкцій **if-else** у Swift допоможе зробити код більш читабельним, підтримуваним та зрозумілим.

## Загальні рекомендації
1. **Ясність і читабельність — головне правило**:
   - Код усередині `if` і `else` має бути легко читабельним і інтуїтивно зрозумілим.
   - Використовуйте зрозумілі умови, уникайте занадто довгих логічних виразів.

2. **Використовуйте `else` тільки за потреби**:
   - Якщо можна уникнути `else`, наприклад, за допомогою раннього виходу (`guard` або `return`), уникайте його.
   - Це покращує читабельність, оскільки зменшує вкладеність коду.

3. **Мінімізуйте вкладеність**:
   - Вкладені конструкції `if`-`else` ускладнюють сприйняття.
   - Краще використовувати ранній вихід (`guard`), щоб запобігти зайвим рівням вкладеності.

4. **Завжди використовуйте фігурні дужки**:
   - Навіть якщо у блоці всього один рядок, додавайте фігурні дужки `{}`. Це знижує ризик помилок під час додавання нових рядків.

## Найкращі практики

### **1. Використовуйте `guard` для раннього виходу**

```swift
func process(input: String?) {
    guard let input else {
        print("Input is nil")
        return
    }
    print("Processing \(input)")
}
```
* Такий підхід дозволяє уникнути блоку else і скоротити вкладеність.

### 2. Використовуйте if-else для простої логіки
Якщо логіка складається з кількох умов:

```swift
if value > 0 {
    print("Positive")
} else if value < 0 {
    print("Negative")
} else {
    print("Zero")
}
```

### 3. Використовуйте тернарний оператор для простих умов
Для простих виразів краще використовувати тернарний оператор:

```swift
let result = value > 0 ? "Positive" : "Negative"
```

* **Важливо: Не використовуйте тернарний оператор для складної логіки, щоб уникнути зниження читабельності.**

### 4. Мінімізуйте кількість умов
Якщо є кілька умов, розгляньте використання switch:

```swift
switch value {
case let x where x > 0:
    print("Positive")
case let x where x < 0:
    print("Negative")
default:
    print("Zero")
}
```

### 5. Уникайте логічного негативу
Неправильно ❌:

```swift
if !isValid {
    print("Invalid")
} else {
    print("Valid")
}
```

Правильно ✅:

```swift
if isValid {
    print("Valid")
} else {
    print("Invalid")
}
```

### 6. Занадто довгі умови:

Розбивайте складні умови на окремі змінні або функції.

```swift
let isEligible = age >= 18 && hasPermission && isRegistered
if isEligible {
    print("Eligible")
}
```

### 7. Ігнорування структури:
Якщо блоки if і else занадто довгі, розгляньте рефакторинг у окремі функції.

### 8. Плутанина в логіці:
Переконайтеся, що гілки if і else не перетинаються і охоплюють усі можливі випадки.

### Висновок
* Робіть умови простими та зрозумілими.
* Використовуйте guard для раннього виходу, щоб уникнути вкладеності.
* Дотримуйтесь узгодженого стилю та пишіть код, який буде легко зрозуміти та підтримувати вашій команді.

# Модифікатори видимості
Модифікатори області видимості всередині класів мають пріоритет у написанні (розташовуються першими):

```swift
class Priority {
    private let constant = 10.0
    private(set) var isReadonly = true
    fileprivate final lazy var alwaysTrue = true

    private final func method() {
    }
}
```

Винятком є спеціальні модифікатори, які починаються з @:

```swift
class MixedCodeView {
    @objc let constant = 10.0
    @IBOutlet private(set) var titleLabel: UILabel!
    @IBAction private func cancelButtonClicked(sender: UIButton) {
    }
}
```

# Readonly
Якщо властивість об'єкта повинна бути доступна лише для читання, використовується модифікатор **private(set)**

```swift
class Weather {
   private(set) var temperature: Temperature
}
```

Якщо ж властивість задається під час ініціалізації об'єкта і не змінюється надалі, використовується **let**

```swift
class Request {
   let timeout: TimeInterval

   init(timeout: TimeInterval) {
      self.timeout = timeout
   }
}
```

# Public, Open, Internal
У межах основного таргета модифікатори **open, public, internal** не використовуються (виняток становлять окремі бібліотеки).

# Fileprivate
Модифікатор **fileprivate** застосовується тільки тоді, коли змінна або метод мають використовуватись одним із розширень об'єкта в межах файлу або пов'язаним fileprivate-об'єктом. Важливо чітко розрізняти області видимості **private** та **fileprivate.**

# Final
Модифікатор final **обов'язково** використовується для об'єктів, які не планується успадковувати (переважна більшість об'єктів).

Для методів, властивостей і сабскриптів, помічених як **final**, компілятор може уникнути використання динамічної диспетчеризації (dynamic dispatch) через таблицю віртуальних функцій (VTable). Натомість використовується статична диспетчеризація, що дозволяє зекономити пам'ять і прискорити доступ.

```swift
final class Service {
}
```


# Make it better

Хорошою практикою э залишати код трохи кращим, ніж він був до вас. Це означає, що, працюючи над функціоналом або виправляючи помилки, варто звертати увагу на загальний стан коду і вносити невеликі покращення там, де це можливо навіть якщо цей код написаний не вами.

### Що це означає на практиці?
   - Видаліть зайві або застарілі частини коду.
   - Розбийте складні функції на менші, зрозумілі методи.
   - Додайте коментарі, якщо код неочевидний.
   - Перевірте, чи відповідає ваш код встановленому кодстайлу команди.
   - Усуньте "дрібні борги", наприклад, неправильне форматування чи дублювання коду.
   - Інше...

### Чому це важливо?

- **Полегшує майбутню підтримку**: Кожен невеликий покращений аспект коду зменшує складність для майбутніх розробників.
- **Формує культуру якості**: Дотримуючись цього принципу, ви подаєте приклад іншим членам команди.

Пам’ятайте: навіть невеликі зміни, такі як виправлення помилки у назві змінної або оновлення застарілого коментаря, роблять ваш код більш якісним і сприяють загальному успіху проєкту.
