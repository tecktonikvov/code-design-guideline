# Ласкаво просимо!

У нашій Swift команді ми дотримуємося встановлених правил та стандартів написання коду, які допомагають підтримувати його чистим, зрозумілим та легким для подальшого розвитку. Основною метою наших принципів є забезпечення єдиного підходу до написання коду, що сприяє кращій командній взаємодії та мінімізує ризики, пов’язані з несумісністю.

# Для кого призначені ці правила?

Ці правила призначені для всіх розробників, які працюють над проєктом, незалежно від їхнього досвіду чи ролі в команді. Вони допомагають:

1. **Новим членам команди**: Швидше адаптуватися до стилю написання коду в проєкті, зрозуміти структуру та підходи до розробки.
2. **Досвідченим розробникам**: Забезпечити єдиний підхід до написання коду і спростити код-рев'ю.
3. **Командам, які підтримують проєкт**: Зробити код більш зрозумілим і легким для підтримки, особливо при масштабуванні проєкту.
4. **Контрактним розробникам**: Полегшити інтеграцію їхнього внеску в основний код проєкту завдяки зрозумілим стандартам.
5. **Усім, хто читає код**: Зменшити когнітивне навантаження за рахунок використання зрозумілого і послідовного стилю написання.

Дотримання цих правил дозволяє підвищити якість коду, сприяє кращій співпраці в команді та забезпечує довготривалу підтримку проєкту.

## Переваги використання єдиного кодстайлу:

- **Зрозумілість**: Уніфікований стиль спрощує читання та розуміння коду всіма членами команди.
- **Легкість підтримки**: Код, написаний за загальними правилами, простіше підтримувати та розвивати в майбутньому.
- **Зниження помилок**: Завдяки дотриманню стандартів зменшується кількість технічних помилок і конфліктів.
- **Ефективність**: Уніфіковані підходи до структуризації та стилю дозволяють зекономити час на рев’ю та інтеграцію коду.
- **Командна згуртованість**: Спільний стиль сприяє кращій взаємодії всередині команди та швидшому залученню нових учасників.

Ознайомтеся з цими правилами перед початком роботи, щоб ваш внесок став важливою частиною успіху нашого проєкту.


# Іменування та правила проектування API

Іменування змінних, класів, методів та іх аргументів є одним із ключових правил під час написання будь-якого коду. Коли члени команди керуються спільними правилами іменування, можна сказати, що вони "говорять однією мовою". Це полегшує розуміння коду під час його читання, а також сприяє ефективній комунікації між розробниками.

## Підходи до іменування та правила проектування API:

- **[ENG Swift API Design Guidelines](https://swift.org/documentation/api-design-guidelines/)**  
- **[RU Swift API Design Guidelines](https://github.com/tecktonikvov/code-design-guideline/blob/main/Swift%20API%20design%20guidelines.pdf)**  

## Кілька важливих правил, які варто пам’ятати:

1. **Читабельність і ясність — головна мета.**  
   Код пишуть значно рідше, ніж читають або використовують в інших місцях. Вибравши правильне ім’я для методу чи змінної один раз, ви спрощуєте їх розуміння іншими розробниками.

2. **Ясність завжди має пріоритет над стислістю.**  
   Незважаючи на те, що в Swift можна писати дуже короткий код, це не повинно бути самоціллю. Назви змінних, методів і класів завжди мають відображати їхнє призначення, навіть якщо це робить їх довшими.

Дотримуючись цих принципів, ви допоможете зробити код вашої команди більш зрозумілим і зручним у роботі.


# Префікси класів

Ми не використовуємо префікси для класів.

Swift автоматично додає префікси до назв класів (за назвою модуля), тому ситуації, коли два класи з однаковими назвами конфліктують, виключені. Якщо ж виникає конфліктна ситуація, можна використати назву модуля, щоб явно вказати, який клас слід використовувати:

```swift
import SomeModule

let service: SomeModule.Service
```

# Використання дужок

У загальному випадку символ "{" не переноситься на новий рядок. Приклади:

* **Умовні операції if, else:**

    ```swift
    if let user = users.first {
        doStuff()
    } else {
        doOtherStuff()
    }
    ```

* **Цикли for, while:**

    ```swift
    for item in items {
        item.doStuff()
    }
    ```

* **Визначення класів, протоколів:**

    ```swift
    protocol ServiceDelegate {
        func service(_ service: Service, didFinishLoading error: Error?)
    }
    ```

* **Використання MARK:**

    ```swift
    class ViewPresenter {
        // MARK: - Private
        private var isShown = false

        // MARK: - Public
        func show() {
            isShown = true
        }
    }
    ```

* **Оператори switch:**

    ```swift
    switch self {
    case .case1: 
        return true
    case .case2: 
        return false
    }
    ```


# Оголошення об'єктів

При оголошенні об'єктів (класи, протоколи) між назвою та початком блоку не робиться перенесення рядка:

```swift
class Formatter {
    var definition
}
```

Вирази Guard
----------------
Під час використання guard-виразів слід дотримуватись загальних правил перенесення рядків:

```swift
func loadData() throws {
    guard !isLoaded else { 
        throw Exception.alreadyLoaded 
    }
}
```

Також дозволяється запис без перенесення, якщо результуючий вираз не є занадто довгим:

```swift
func createViewIfNeeded() {
    guard view == nil else { return }
}
```

Модифікатори видимості
----------------
Модифікатори області видимості всередині класів мають пріоритет у написанні (розташовуються першими):

```swift
class Priority {
    private let constant = 10.0
    private(set) var isReadonly = true
    fileprivate final lazy var alwaysTrue = true

    private final func method() {
    }
}
```

Винятком є спеціальні модифікатори, які починаються з @:

```swift
class MixedCodeView {
    @objc let constant = 10.0
    @IBOutlet private(set) var titleLabel: UILabel!
    @IBAction private func cancelButtonClicked(sender: UIButton) {
    }
}
```

Readonly
--------
Якщо властивість об'єкта повинна бути доступна лише для читання, використовується модифікатор **private(set)**

```swift
class Weather {
   private(set) var temperature: Temperature
}
```

Якщо ж властивість задається під час ініціалізації об'єкта і не змінюється надалі, використовується **let**

```swift
class Request {
   let timeout: TimeInterval

   init(timeout: TimeInterval) {
      self.timeout = timeout
   }
}
```

Public, Open, Internal
----------------------
У межах основного таргета модифікатори **open, public, internal** не використовуються (виняток становлять окремі бібліотеки).

Fileprivate
-----------
Модифікатор **fileprivate** застосовується тільки тоді, коли змінна або метод мають використовуватись одним із розширень об'єкта в межах файлу або пов'язаним fileprivate-об'єктом. Важливо чітко розрізняти області видимості **private** та **fileprivate.**

Final
-----
Модифікатор final **обов'язково** використовується для об'єктів, які не планується успадковувати (переважна більшість об'єктів).

Для методів, властивостей і сабскриптів, помічених як **final**, компілятор може уникнути використання динамічної диспетчеризації (dynamic dispatch) через таблицю віртуальних функцій (VTable). Натомість використовується статична диспетчеризація, що прискорює виклики.

Статична диспетчеризація дозволяє компілятору напряму викликати метод, обходячи таблицю віртуальних функцій.

Якщо клас або метод позначений як **final**, компілятор не додає їх до таблиці віртуальних функцій, що дозволяє зекономити пам'ять і прискорити доступ.

```swift
final class Service {
}
```


# Make it better

Хорошою практикою э залишати код трохи кращим, ніж він був до вас. Це означає, що, працюючи над функціоналом або виправляючи помилки, варто звертати увагу на загальний стан коду і вносити невеликі покращення там, де це можливо навіть якщо цей код написаний не вами.

## Що це означає на практиці?
   - Видаліть зайві або застарілі частини коду.
   - Розбийте складні функції на менші, зрозумілі методи.
   - Додайте коментарі, якщо код неочевидний.
   - Перевірте, чи відповідає ваш код встановленому кодстайлу команди.
   - Усуньте "дрібні борги", наприклад, неправильне форматування чи дублювання коду.
   - Інше...

## Чому це важливо?

- **Полегшує майбутню підтримку**: Кожен невеликий покращений аспект коду зменшує складність для майбутніх розробників.
- **Формує культуру якості**: Дотримуючись цього принципу, ви подаєте приклад іншим членам команди.

Пам’ятайте: навіть невеликі зміни, такі як виправлення помилки у назві змінної або оновлення застарілого коментаря, роблять ваш код більш якісним і сприяють загальному успіху проєкту.
